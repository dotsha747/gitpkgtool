#! /usr/bin/perl

# gitpkgtool by shahada AT abubakar.net
# 
# Copyright (C) 2011, Shahada Abubakar
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# For the latest source, see http://home.abubakar.net/pubdocs

use strict;
use Getopt::Long;
use Cwd;
use File::Basename;
use File::Temp;
use POSIX;
use Data::Dumper;

my $helpflag = 0;
my $debug = 0;

# process command line arguments

if (scalar (@ARGV) ==0 || $ARGV[0] eq 'help' || $ARGV[0] eq '--help') {
	print STDERR 	"\nUsage: gitpkgtool <command> [--options]\n".
								"\n".
								"Commands:\n".
								"  nexttag\n".
								"  - tags the next build number [old style]\n".
								"  nextversion\n".
								"  - tags the next minor version number\n".
								"  nextversionmajor\n".
								"  - tags the next major version number\n".
								"  buildrpm\n".
								"  - builds rpm package file\n".
								"  buildrpmsource\n".
								"  - builds rpm from spec and sources\n".
								"  builddeb\n".
								"  - builds deb package file\n".
								"  buildsetup\n".
								"  - builds InnoSetup setup.exe\n".
								"  buildipk\n".
								"  - builds opkg package file\n".
								"	 buildnsis\n".
								"  - builds windows installer .exe using nsis\n".
								"\n".
								"run \"gitpkgtool <command> --help\" for further options\n\n";

	exit (0);
}

elsif ($ARGV[0] eq 'nexttag') {
	nexttag ();
}

elsif ($ARGV[0] eq 'buildrpm') {
	buildrpm ();
}

elsif ($ARGV[0] eq 'buildrpmsource') {
	buildrpmsource ();
}

elsif ($ARGV[0] eq 'builddeb') {
	builddeb ();
}

elsif ($ARGV[0] eq 'nextversion') {
	nextversion();
} 
elsif ($ARGV[0] eq 'buildsetup') {
	buildsetup();
}
elsif ($ARGV[0] eq 'buildipk') {
  buildipk();
}
elsif ($ARGV[0] eq 'buildnsis') {
	buildnsis();
} else {
	print STDERR "Unknown command \"" . $ARGV[0] . "\"\n";
};


exit (0);


# ========================================================================
# tags the last commit with a build tag. The build tag number is 
# incremented from the highest, last, tag number.
# ------------------------------------------------------------------------

sub nexttag {

	shift @ARGV;

	my $verbose = 0;
	my $dontpush = 0;

	my ($opt) = GetOptions (
		'help'		=> \$helpflag,
		'verbose' => \$verbose,
		'debug'		=> \$debug,
		'dontpush'	=> 	\$dontpush
	);

	if (!$opt || $helpflag) {
		print STDERR 
			"\ngitpkgtool nexttag [--dontpush] [--verbose] [--debug]\n".
			"\ntags the current repo with a sequence in the form (BRANCH-)nnnn\n\n";
		exit (1);
	};

	# figure out current branch
	open (F, "git branch| grep \"^\\*\\s\"|") || die 
		"Cannot open pipe to git branch";
	my $branch = <F>;
	close (F);
	chomp ($branch);
	$branch =~ s/^\*\s//;
	print "MY branch [$branch]\n";

	# special case
	if ($branch eq 'master') {
		$branch = "B";
	} else {
		$branch .= "-";
	}

	my $nowver = 0;
	open (F, "git tag|");
	while ( my $line = <F>) {
		if (my ($ver) = $line =~ /^${branch}(\d+)$/) {
			print "Found $line";
			if ($ver > $nowver) {
				$nowver = $ver;
			};
		};
	};

	my $nextver = $nowver + 1;
	printf "%sTagging as ${branch}${nextver}\n",
		($verbose ? "Latest is ${branch}${nowver}, " : "");
	call_system ("git tag -a -m \"build ${branch}${nextver}\" ${branch}${nextver}");

	if (! $dontpush) {
		call_system ("git push --tags");
	};

};


# ========================================================================
# nextversion
# tags the next minor version (replaces nexttag)
# ------------------------------------------------------------------------

sub nextversion {

	shift @ARGV;

	my $verbose = 0;
	my $dontpush = 0;

	my ($opt) = GetOptions (
		'help'		=> \$helpflag,
		'verbose' => \$verbose,
		'debug'		=> \$debug,
		'dontpush'	=> 	\$dontpush
	);

	# make sure we are on master branch
	my $branch = getCurrentBranch();
	if ($branch ne 'master') {
		print STDERR "gitpkgtool: Not on master branch, please switch with \"git checkout master\"\n";
		exit (1);
	}

	my ($major, $minor) = getLatestVersion();

	if ($major == 0 && $minor == $0) {
		$major = 1; 
		$minor = 0;
	} else {
		$minor++;
	};

	printf "gitpkgtool: assigning next minor version V${major}-${minor}\n";

	call_system ("git tag -a -m \"Version ${major}-${minor} assigned by gitpkgtool\" V${major}-${minor}");

	print "You probably want to do this now:\n" .
				"  git checkout dev; git merge --no-ff master\n\n";
	
	if (! $dontpush) {
		call_system ("git push --tags");
	};
	exit (0);
}

# ========================================================================
# nextversionmajor
# tags the next major version (replaces nexttag)
# ------------------------------------------------------------------------

sub nextversionmajor {

	shift @ARGV;

	my $verbose = 0;
	my $dontpush = 0;

	my ($opt) = GetOptions (
		'help'		=> \$helpflag,
		'verbose' => \$verbose,
		'debug'		=> \$debug,
		'dontpush'	=> 	\$dontpush
	);

	# make sure we are on master branch
	my $branch = getCurrentBranch();
	if ($branch ne 'master') {
		print STDERR "gitpkgtool: Not on master branch, please switch with \"git checkout master\"\n";
		exit (1);
	}

	my ($major, $minor) = getLatestVersion();

	if ($major == 0 && $minor == $0) {
		$major = 1; 
		$minor = 0;
	} else {
		$major++;
		$minor=0;
	};

	printf "gitpkgtool: assigning next minor version V${major}-${minor}\n";

	call_system ("git tag -a -m \"Version ${major}-${minor} assigned by gitpkgtool\" V${major}-${minor}");

	print "You probably want to do this now:\n" .
				"  git checkout dev; git merge --no-ff master\n\n";
	
	if (! $dontpush) {
		call_system ("git push --tags");
	};
	exit (0);
}

# ========================================================================
# build rpm
# ------------------------------------------------------------------------

sub buildrpm {

	shift @ARGV;

	my $verbose = 0;

	our $pub_cmd = $ENV{'GITPKGTOOL_PUB_CMD'};
	our $pub_dir = $ENV{'GITPKGTOOL_PUB_DIR'};
	our $pub_postexec = $ENV{'GITPKGTOOL_PUB_POSTEXEC'};
	our $pub     = 0;
	our $pubsrc  = 0;
	our $forcename;

	if ( -e ".gitpkgtool" ) {
	  require "./.gitpkgtool"
	}

	my ($opt) = GetOptions (
		'help'	=> \$helpflag,
		'verbose' => \$verbose,
		'debug' => \$debug,
		'pub_cmd=s' => \$pub_cmd,
		'pub_dir=s' => \$pub_dir,
		'pub_postexec=s' => \$pub_postexec,
		'pub' => \$pub,
		'pubsrc' => \$pubsrc,
		'forcename=s' => \$forcename
	);

	if (!$opt || $helpflag) {
		print STDERR 
			"\ngitpkgtool buildrpm [--options] <tag> [source]\n".
			"\nOptions:\n".
			"  --verbose - emits running commentary\n".
			"  --debug - show details of external commands\n".
			"  --pub_cmd - command to exec when publishing\n".
			"  --pub_dir - user\@host:/dir of scp dest for publishing\n".
			"  --pub_postexec - execute command after publishing\n".
			"  --pub     - publish the Binary RPMS\n".
			"  --pubsrc  - publish the Binary & Source RPMS\n".
			"  --forcename branch - overwrite actual branch\n";
		exit (1);
	};


	my ($buildtag, $reposource) = @ARGV;

	# prepare RPM build area
	# We now use "rpmdev-setuptree" from rpmdevtools for this. Which
	# means the rpm build dir has moved from ~/rpm to ~/rpmbuild.

	$verbose && print STDERR " * Preparing RPM build area\n";
	call_system ("rm -rf ~/rpmbuild");
	call_system ("rpmdev-setuptree");

	
	#$debug && print STDERR "   Writing " . $ENV{'HOME'}."/.rpmrc\n";
	#open (F, "> " . $ENV{'HOME'} . "/.rpmrc") ||
	#	die "Failed to open " . $ENV{'HOME'} . "/.rpmrc for writing.\n";
	#print F "buildarchtranslate: i386: i386\n";
	#print F "buildarchtranslate: i486: i386\n";
	#print F "buildarchtranslate: i586: i386\n";
	#print F "buildarchtranslate: i686: i386\n";
	#print F "buildarchtranslate: athlon: i386\n";
	#close (F);

	# make some other folders that we need.

	foreach my $d (
			$ENV{'HOME'} . "/rpmbuild/tmp",
			$ENV{'HOME'} . "/rpmbuild/git",
			$ENV{'HOME'} . "/rpmbuild/tar",
	) {
			$debug && print STDERR "   Creating folder $d\n";
			call_system ("rm -rf $d");
			mkdir $d || die "Failed to mkdir $d\n";
	};


	my $dir = ".";
	my $project = "";

	if (defined $reposource) {
		
		# user specified a repo to pull frm
		$dir = $ENV{'HOME'} . "/rpmbuild/git";
		$verbose && print STDERR " * Cloning $reposource to $dir\n";

		mkdir $dir;
		chdir $dir;

		# clone the repo
		my $ret = call_system ("git clone -q $reposource") &&
			die "\"git clone $reposource\" failed.";

		# we need the name of the project
		opendir (DH, $dir);
		while ( my $fn = readdir (DH)) {
			if ($fn !~ /^\./) {
				$project = $fn;
			};
		};
		closedir (DH);
		chdir ($dir . "/" . $project) ||
			die "Failed to chdir to $dir/$project\n";

	} else {

		# use source in current directory.
		my $nowdir = cwd;
		$verbose && print STDERR " * Using source in $nowdir\n";

		$project = basename ($nowdir);
	};

	my $currentBranch = getCurrentBranch();
	if ($currentBranch eq 'master' || $currentBranch eq '') {
		$currentBranch = '';
	} else {
		$currentBranch = '_' . $currentBranch;
	}


	# Checkout the specified build
	if ($buildtag ne '') {
		$verbose && print STDERR " * Checking out build $buildtag\n";
		call_system ("git checkout -q $buildtag");
	};

	$verbose && print STDERR " * Cleaning project source $project\n";

	# if it has a makefile, call "make distclean"
	if ( -e "Makefile" || -e "makefile" ) {
		call_system ("make distclean 2>&1 > /dev/null");
	};

	# if it's Eclipse, look for Release* and Debug* subdirectories.
	opendir (DH, ".");
	while (my $fn = readdir (DH)) {
		if ( ($fn =~ /^Release/ && -d $fn) ||
		     ($fn =~ /^Debug/ && -d $fn) ) {
			chdir ($fn);
			call_system ("make clean 2>&1 > /dev/null");
			chdir ("..");
		};
	};

	# get the current git version from "git describe"
	open (F, "git describe|") || die "Unable to pipe from \"git describe\"";
	$buildtag = <F>;
	close (F);
	chomp $buildtag;
	if ($buildtag eq '') {
		die ("source is not tagged properly, unable to build.\n");
	};

	# work up a version number
	my $version = buildToVersion ($buildtag);
	$verbose && print STDERR " * building $buildtag as version $version\n";


	# copy into a folder of $project-$version 
	mkdir $ENV{'HOME'} . "/rpmbuild/tar/${project}${currentBranch}-$version";
	call_system ("tar czf - --exclude ".
		"./$project.spec --exclude ./.git --exclude ./debian . | tar xpzfC ".
		"- " . $ENV{'HOME'} . "/rpmbuild/tar/${project}${currentBranch}-${version}") &&
		die "Failed to build temporary tarfile";

	# call "gitpkgtool-buildrpm-post-source-copy-hook" if it exists
	if (-x "gitpkgtool-buildrpm-post-source-copy-hook" ) {
		$verbose && print STDERR " * Calling gitpkgtool-buildrpm-post-source-copy-hook\n";
		my $ret = call_system ("./gitpkgtool-buildrpm-post-source-copy-hook \"${version}\" \"" . $ENV{'HOME'} . "/rpmbuild/tar/" . "${project}${currentBranch}-${version}\"");
		if ($ret != 0) {
			die "failed calling gitpkgtool-buildrpm-post-source-copy-hook\n";
		}
	};

	# build the SOURCE tar file
	my $tarfile = $ENV{'HOME'} . "/rpmbuild/SOURCES/${project}${currentBranch}-${version}.tar.gz";
	call_system ("tar c" . ($debug ? "v":"") . "zfC $tarfile ".
		$ENV{'HOME'} . "/rpmbuild/tar ${project}${currentBranch}-${version}") 
		&& die "Failed to build $tarfile\n";
	$verbose && print STDERR " * source tarball is in $tarfile\n";


	# copy the SPEC file over, setting version numbers and editing
	# other tags on the fly.
	my $specfile = $ENV{'HOME'} . "/rpmbuild/SPECS/$project.spec";
	open (FO, "> $specfile");

	printf FO "%%define _git_branch %s\n", 
		$currentBranch eq '' ? '%{nil}' : $currentBranch;

	# parse through specfile
	open (FI, "$project.spec") || die "There is no $project.spec file in ".
		"the source.\n";
	while (my $line = <FI>) {
		# replace version number
		if ($line =~ /^Version:/) {
			$line = "Version: $version\n";
		};
		if ($line =~ /^Source:/) {
			$line = "Source: ${project}${currentBranch}-${version}.tar.gz\n";
		};
		if ($line =~ /^Release:/) {
			$line = "Release: 1%{?dist}{?repo}\n";
		};

		if ($line =~ /^Name:/) {
			if (defined $forcename) {
				$line = "Name: $forcename\n";
			};
		};

		if ($line =~ /^%changelog/) {

			# generate changelog from git log

			print FO "%changelog\n";
			my $lastauthor = "";
			open (FC, "git log |");
			while (my $line = <FC>) {
				chomp ($line);
				if ($line =~ /^commit/) { next; };
				if ($line =~ /^Merge:/) { next; };
				if ($line =~ /^Author:\s(.*)$/) {
					$lastauthor = $1;
					next;
				};
				if ($line =~ /^Date:\s+(\w+)\s+(\w+)\s+(\w+)\s+[\w:]+\s(\d+)\s/) {
					print FO "\n * $1 $2 $3 $4 $lastauthor\n";
					next;
				};
				if ($line =~ /^\s*$/) {
					next;
				};
				$line =~ s/^\s+//;
				print FO " - $line\n";
			};
			close (FC);
			next;
		};

		# pass through other spec file lines
		print FO $line;
	};
	close (FI);

	close (FO);
	$verbose && print STDERR " * RPM SPEC is in $specfile\n";

	# invoke rpmbuild
	$verbose && print STDERR " * Invoking rpmbuild ...\n";
	call_system ("rpmbuild -ba " . ($debug ? "": "--quiet ") . "$specfile") &&
		die ("rpmbuild of $project.spec failed.\n");

	# scp
	my $findcmd = "find " . $ENV{'HOME'} . "/rpmbuild -type f -name \*.rpm " .
		($pub ? " ! -name \\*src.rpm" : "");
	if ($pub || $pubsrc) {
		my $filelist;
		open (F, "$findcmd |");
		while (my $line = <F>) {
			chomp $line;
			$filelist .= $line . " ";
		};
		my $pubcmd = $pub_cmd . " $filelist ".  $pub_dir;
		$verbose && print STDERR " * Publishing files ...\n";
		call_system ($pubcmd);

		if (defined $pub_postexec) {
			$verbose && print STDERR " * Executing post-publish script ...\n";
			call_system ($pub_postexec);
		}
	};
	
	# list output 
	$verbose && print STDERR " * Output:\n\n";
	call_system ($findcmd);
	$verbose && print STDERR "\n\n";



};



# ========================================================================


sub call_system { 

	my ($cmd) = @_;

	$debug && print STDERR "   Exec \"$cmd\"\n";
	system ($cmd);
	if ($? == -1) {
		die ("Failed to execute \"$cmd\"\n");
	}
	elsif ( $? & 127) {
		die ("   Child \"$cmd\" died with signal %d, %s coredump\n",
			($? & 127),  ($? & 128) ? 'with' : 'without'
		);
	}
	else {
		$debug && printf "   Child \"$cmd\" exited with %d\n", $? >> 8;
	};

	return $? >> 8;

};



# ========================================================================
# Convert a build number, which may be something like B(count), or
# (branch)-(count).
# If the branch has been committed to since the last tag, then it may
# take the form B(count)-n-hex, or (branch)-(count)-n-hex.
#
# eg: dev-2-1-g14442f4
#
# We need to map this to (count).n.hex(.branch)
# If branch is "B" (master branch) then we can leave it out.
#
# ------------------------------------------------------------------------

sub buildToVersion {

	my ($build) = @_;

	# new style V tags

	if (my ($a) = $build =~ /^V(.*)$/) {
		$a =~ s/-/./g;
		return "${a}";
	}

	# old style B tags
	elsif (my ($a, $b, $c) = $build =~ /^B(\d+)-(\d+)-(.+)$/) {
		return "${a}.${b}.${c}";
	} 
	elsif (my ($a) = $build =~ /^B(\d+)$/) {
		return "${a}";
	} 
	elsif ( my ($a, $b, $c, $d) = $build =~ /^(\w+)-(\d+)-(\d+)-(.+)$/) {
		return "${b}.${c}.${d}.${a}";
	} 
	elsif ( my ($a, $b, $c) = $build =~ /^(\w+)-(\d+)$/) {
		return "${b}.${a}";
	}
	else {
		die "Unable to convert $build to a version number\n";
	};

}





# ========================================================================
# get the current branch name
# ------------------------------------------------------------------------

sub getCurrentBranch {

	# figure out current branch
	open (F, "git branch| grep \"^\\*\"|") || die 
		"Cannot open pipe to git branch";
	my $branch = <F>;
	close (F);
	chomp ($branch);
	$branch =~ s/^\*\s//;

	if ($branch eq '') {
		$branch = "master";
	};

	return $branch;
}


# ========================================================================
# gets latest version number from V{x}-{y} tags.
# ------------------------------------------------------------------------

sub getLatestVersion {

	my $major = 0;
	my $minor = 0;

	# read in all the tags
	open (F, "git tag| grep \"^V\" |") || die "Cannot open pipe to git tag";
	while (my $tagline = <F>) {
		#print "received $tagline\n";
		my ($thisMajor, $thisMinor) = $tagline =~ /V(\d+)-(\d+)/;
		if ($thisMajor > $major) {
			$major = $thisMajor;
		};
		if ($thisMajor == $major &&
		    $thisMinor > $minor) {
			$minor = $thisMinor;
		};
		    
	};
	close (F);
	#print "latest is $major.$minor\n";
	return ($major, $minor);

}


# ========================================================================
# build deb
# ------------------------------------------------------------------------


sub builddeb {

	shift @ARGV;

	my $verbose = 0;
	my $publish = undef;
	my $pubsrc = undef;

	if ( -e ".gitpkgtool" ) {
	  require "./.gitpkgtool"
	}

	my ($opt) = GetOptions (
		'help'	=> \$helpflag,
		'verbose' => \$verbose,
		'debug' => \$debug,
		'publish' => \$publish,
		'pubsrc' => \$pubsrc
	);


	if (!$opt || $helpflag) {
		print STDERR 
			"\ngitpkgtool builddeb [--options] <tag> [source]\n".
			"\nOptions:\n".
			"  --verbose - emits running commentary\n".
			"  --debug - show details of external commands\n".
			"  --publish - publish after build\n";
		exit (1);
	};

	# choose somewhere far away to work in
	$verbose && print STDERR " * Preparing work area " . $ENV{'HOME'}."/deb\n";
	call_system ("rm -rf " . $ENV{'HOME'} . "/deb");
	mkdir $ENV{'HOME'} . "/deb";
	

	my ($buildtag, $reposource) = @ARGV;

	my $dir = ".";
	my $project = "";

	if (defined $reposource) {
		
		# user specified a repo to pull frm
		$dir = $ENV{'HOME'} . "/deb/git";
		$verbose && print STDERR " * Cloning $reposource to $dir\n";

		mkdir $dir;
		chdir $dir;

		# clone the repo
		my $ret = call_system ("git clone -q $reposource") &&
			die "\"git clone $reposource\" failed.";

		# we need the name of the project
		opendir (DH, $dir);
		while ( my $fn = readdir (DH)) {
			if ($fn !~ /^\./) {
				$project = $fn;
			};
		};
		closedir (DH);
		chdir ($dir . "/" . $project) ||
			die "Failed to chdir to $dir/$project\n";

	} else {

		# use source in current directory.
		my $nowdir = cwd;
		$verbose && print STDERR " * Using source in $nowdir\n";

		$project = basename ($nowdir);

	};


	# Checkout the specified build
	if ($buildtag ne '') {
		$verbose && print STDERR " * Checking out build $buildtag\n";
		call_system ("git checkout -q $buildtag");
	};

	$verbose && print STDERR " * Cleaning project source $project\n";

	# if it has a makefile, call "make distclean"
	if ( -e "Makefile" || -e "makefile" ) {
		call_system ("make distclean 2>&1 > /dev/null");
	};

	# if it's Eclipse, look for Release* and Debug* subdirectories.
	opendir (DH, ".");
	while (my $fn = readdir (DH)) {
		if ( ($fn =~ /^Release/ && -d $fn) ||
		     ($fn =~ /^Debug/ && -d $fn) ) {
			chdir ($fn);
			call_system ("make clean 2>&1 > /dev/null");
			chdir ("..");
		};
	};

	# get the current git version from "git describe"
	open (F, "git describe|") || die "Unable to pipe from \"git describe\"";
	$buildtag = <F>;
	close (F);
	chomp $buildtag;
	if ($buildtag eq '') {
		die ("source is not tagged properly, unable to build.\n");
	};

	# debianize the project name
	my $package = lc $project;
	$verbose && print STDERR " * Debianized package name is $package\n";

	# work up a version number 
	my $version = buildToVersion ($buildtag);

	$verbose && print STDERR " * Extracted build tag as version \"$version\"\n";



	# is this a lib package?
	my $originalVersion = $version;
	my $sover="";
	if ($project=~ /^lib/) {
		($sover, $version) = $version =~ /(\d+)\.(.*)/;
		$verbose && print STDERR " * Detected lib, so building as package \"${package}${sover}\" and version \"$version\"\n";
	};



	# copy into a folder of ${package}${sover}-${version}
	mkdir $ENV{'HOME'} . "/deb/tar";
	mkdir $ENV{'HOME'} . "/deb/tar/${package}${sover}-${version}";
	call_system ("tar czf - --exclude ".
		"./$project.spec --exclude ./.git --exclude ./debian . | tar xpzfC ".
		"- " . $ENV{'HOME'} . "/deb/tar/${package}${sover}-${version}") &&
		die "Failed to build temporary tarfile";

	
	# is there a .patchversion.sh script?
	if ( -x $ENV{'HOME'} . "/deb/tar/${package}${sover}-${version}/patchVersion.sh" ) {
		my ($majorVersion, $minorVersion) = $originalVersion =~ /(\d+)\.(.*)/;
		$verbose && print STDERR " * Patching source with project ${project} majorVersion $majorVersion minorVersion $minorVersion\n";
		call_system ("cd $ENV{'HOME'}/deb/tar/${package}${sover}-${version}; ./patchVersion.sh \"$project\" \"$majorVersion\" \"$minorVersion\"");
	};



	# build the SOURCE tar file
	my $tarfile = $ENV{'HOME'} . "/deb/${package}${sover}_${version}.orig.tar.gz";
	call_system ("tar c" . ($debug ? "v":"") . "zfC $tarfile ".
		$ENV{'HOME'} . "/deb/tar ${package}${sover}-${version}") 
		&& die "Failed to build $tarfile\n";
	$verbose && print STDERR " * source tarball is in $tarfile\n";

	# we no longer need the "tar" subfolder
	call_system ("rm -rf $ENV{'HOME'}/deb/tar");

	# extract back the tarball into the build dir
	$verbose && print STDERR " * extracting tarball to build dir\n";
	call_system ("tar xp". ($debug ? "v" :"") ."fC $tarfile " . 
		$ENV{'HOME'}. "/deb");

	# copy over debian subfolder
	call_system ("cp -a debian " . $ENV{'HOME'}. "/deb/${package}${sover}-${version}/");

	# fix permissions
	# .install must not have execute bit set, will complain can't find files.
	opendir (my $D, $ENV{'HOME'} . "/deb/${package}${sover}-${version}/debian");
	foreach my $file (readdir ($D)) {
		if ($file =~ /\.install$/) {
			chmod 0644, $ENV{'HOME'} . "/deb/${package}${sover}-${version}/debian/" .$file;
		}
	};

	# call patchDebian.sh to make changes to debian/ folder
	if ( -x $ENV{'HOME'} . "/deb/${package}${sover}-${version}/patchDebian.sh" ) {
		my ($majorVersion, $minorVersion) = $originalVersion =~ /(\d+)\.(.*)/;
		$verbose && print STDERR (" * patching debian control files with project ${project} majorVersion ${majorVersion} minorVersion ${minorVersion}\n");
		call_system ("cd $ENV{'HOME'}/deb/${package}${sover}-${version}; ./patchDebian.sh \"${project}\" \"${majorVersion}\" \"${minorVersion}\"");
	};


	# grep maintainer email from debian/control
	my $maintainer = "nobody\@nobody.org";
	my $controlfile = $ENV{'HOME'} . "/deb/${package}${sover}-${version}/debian/control";
	open (F, $controlfile) || die "Failed to open $controlfile\n";
	while ( my $line = <F>) {
		if ($line =~ /^Maintainer:\s(.*)$/) {
			$maintainer = $1;
		};
	};
	close (F);

	# overwrite a changelog with current version
	my $changelogfile = $ENV{'HOME'} . "/deb/${package}${sover}-${version}/debian/changelog";
	open (F, "> $changelogfile") || die "Failed to open $changelogfile ".
		"for writing\n";
	print F "${package}${sover} ($version) unstable; urgency=low\n\n";
	print F "  * Release $buildtag via gitpkgtool\n\n";
	print F " -- $maintainer  " . strftime ("%a, %d %b %Y %H:%M:%S %z",
		localtime()) . "\n";
	close (F);

	$verbose && print STDERR " * Building deb source and binary package\n";
	chdir ($ENV{'HOME'} . "/deb/${package}${sover}-${version}");
	call_system ("dpkg-buildpackage");

	# compile list of all RPMs


	my $findcmd = "find " . $ENV{'HOME'} . "/deb -maxdepth 1 -type f ".
		"-name \*.deb " . ($pubsrc ? " -o -name \*dsc" : "") ;
	
	my @packages;
	open (F, "$findcmd |");
	while (my $line = <F>) {
		chomp $line;
		push @packages, $line;
	};


	# list output 
		print " * Output:\n\n";
			foreach my $pkg (@packages) {
				print "$pkg\n";
			};
	print "\n\n";

	if ($publish) {
		$verbose && print STDERR " * publishing packages ...\n";
		call_system ($ENV{'HOME'} . "/deb/${package}${sover}-${version}/publish-deb.sh " . join (" ", map { "\"" . $_ . "\"" } @packages)); 
	};

	$verbose && print STDERR " * DONE\n";

}

# ========================================================================
# buildipk
#
# build for opkg package installer.
#
# Provide "--gitsrc" and "--gitbranch" to clone source from a repo. 
# Otherwise, current directory is assumed.
#
# It will assume makefile in source folder. Otherwise, it will look
# for Eclipse "Release/makefile". Specify --buidlconfig to change 
# "Release" to something else, e.g. "Debug-NX7260".
#
# You will need opkg folder under source, containing:
# opkg/control/control
# opkg/control/preinst
# opkg/control/prerm
# opkg/control/postinst
# opkg/control/postrm
# opkg/control/patchsrcversion.sh {rootdir} {version}
# opkg/control/install.sh {rootdir}
# opkg/control/publish.sh  {file.opkg}
#
# .gitpkgtool in source can override default variables.
# ------------------------------------------------------------------------

sub buildipk {

	
	shift @ARGV;

	my $verbose = 0;

	our $gitsrc;
	our $gittag;
	our $buildconfig = "Release";
	our $publish;

	if ( -e ".gitpkgtool" ) {
	  require "./.gitpkgtool"
	}

	my ($opt) = GetOptions (
		'help'	=> \$helpflag,
		'verbose' => \$verbose,
		'debug' => \$debug,
		'gitsrc=s' => \$gitsrc,
		'gittag=s' => \$gittag,
		'buildconfig=s' => \$buildconfig,
		'publish' => \$publish
	);

	if (!$opt || $helpflag) {
		print STDERR 
			"\ngitpkgtool buildipk [--options] \n".
			"\nOptions:\n".
			"  --verbose - emits running commentary\n".
			"  --debug - show details of external commands\n".
			"  --gitsrc - URI to git clone source\n".
			"  --gittag - git tag/branch to checkout\n".
			"  --buildconfig - Eclipse buildconfig to use. Defaults to \"Release\"\n".
			" --publish - publish the .ipk\n";
		exit (1);
	};


	# choose somewhere far away to work in (~/opkg/)
	$verbose && print STDERR " * Preparing work area " . $ENV{'HOME'}."/opkg\n";
	call_system ("rm -rf " . $ENV{'HOME'} . "/opkg");
	mkdir $ENV{'HOME'} . "/opkg";
	mkdir $ENV{'HOME'} . "/opkg/src";

	my $version;
	my $project;
	my $currentBranch;
	my $dir; # source is here

	if (defined $gitsrc) {

		# user specified a git repo to clone from
		$dir = $ENV{'HOME'} . "/opkg/src";
		$verbose && print STDERR " * Cloning $gitsrc to $dir\n";

		mkdir $dir;
		chdir $dir;

		# clone the repo
		my $ret = call_system ("git clone -q $gitsrc") &&
			die "\"git clone $gitsrc\" failed.";

		# we need the name of the project -- the dir git created.
		opendir (DH, $dir);
		while ( my $fn = readdir (DH)) {
			if ($fn !~ /^\./) {
				$project = $fn;
			};
		};
		closedir (DH);
		chdir ($dir . "/" . $project) ||
			die "Failed to chdir to $dir/$project\n";
		$dir .= "/" . $project;

		# Checkout the specified tag/branch (buildtag)
		if ($gittag ne '') {
			$verbose && print STDERR " * Checking out tag/branch $gittag\n";
			call_system ("git checkout -q $gittag");
		};

		# get the current git version from "git describe"
		open (F, "git describe|") || die "Unable to pipe from \"git describe\"";
		my ($buildtag) = <F>;
		close (F);
		chomp $buildtag;
		if ($buildtag eq '') {
			die ("source is not tagged properly, unable to build.\n");
		};

		# work up a version number
		$version = buildToVersion ($buildtag);
		$verbose && print STDERR " * building as version $version\n";

		$currentBranch = getCurrentBranch();
		if ($currentBranch eq 'master' || $currentBranch eq '') {
			$currentBranch = '';
		} else {
			$currentBranch = '_' . $currentBranch;
		}
	
	} else {

		# use source in current directory.
		my $nowdir = cwd;
		$verbose && print STDERR " * Using source in $nowdir\n";

		# get the current git version from "git describe"
		open (F, "git describe|") || die "Unable to pipe from \"git describe\"";
		my ($buildtag) = <F>;
		close (F);
		chomp $buildtag;
		if ($buildtag eq '') {
			die ("source is not tagged properly, unable to build.\n");
		};

		# work up a version number
		$version = buildToVersion ($buildtag);
		$verbose && print STDERR " * building $buildtag as version $version\n";

		$currentBranch = getCurrentBranch();
		if ($currentBranch eq 'master' || $currentBranch eq '') {
			$currentBranch = '';
		} else {
			$currentBranch = '_' . $currentBranch;
		}

		# project is current folder name
		$project = basename ($nowdir);

		# copy into a folder of $project-$version 
		$dir = $ENV{'HOME'} . "/opkg/src/${project}${currentBranch}-$version";
		mkdir $dir;
		call_system ("tar czf - ".
		" --exclude ./.git  . | tar xpzfC ".
		"- " . $ENV{'HOME'} . "/opkg/src/${project}${currentBranch}-${version}") &&
		die "Failed to build temporary src copy";

	};

	$verbose && print " * Building ${project}${currentBranch}-$version.ipk\n";

	my $redir = $verbose ? "" : " 2>&1 >/dev/null";
	my $dredir = $debug ? "" : " 2>&1 >/dev/null";

	# set permissions on control files and scripts, ignoring if they
	# are not found.

	foreach my $p (
		"control/postinst",
		"control/postrm",
		"control/preinst",
		"control/prerm",
		"patchsrcversion.sh",
		"install.sh",
		"publish.sh"
	) {
		chmod 0755, $dir . "/opkg/" . $p;
	};

	# if it has a makefile, use that.
	if ( -e $dir . "/Makefile" || -e $dir . "/makefile" ) {

		$verbose && print " * Found \"makefile\".\n";

		if ( -e $dir . "/opkg/patchsrcversion.sh") {
			$verbose && print " * Patching version \"$version\" into source.\n";
			call_system ($dir . "/opkg/patchsrcversion.sh \"$dir\" \"$version\"") && 
				die $dir . "/opkg/patchsrcversion.sh returned non-zero result\n";;
		};

		# do a make distclean
		call_system ("make distclean 2>&1 > /dev/null");

		# do a make
		$verbose && print " * Building ...\n";
		call_system ("make " . $redir);

	} 
	elsif ( -e $dir . "/build.xml" ) {
		
		# if it has a build.xml, use ant and build it.
		$verbose && print " * Found \"build.xml\".\n";

		call_system ("ant clean");

		$verbose && print " * Building ...\n";
		call_system ("ant build");

	} 
	elsif (  -e $dir . "/" . $buildconfig . "/makefile" ) { 

		# Test to see if we're eclipse. Look for $buildconfig

		$verbose && print " * Found Eclipse ${buildconfig}/makefile.\n";

		if ( -e $dir . "/opkg/patchsrcversion.sh") {
			$verbose && print " * Patching version \"$version\" into source.\n";
			call_system ($dir . "/opkg/patchsrcversion.sh \"$dir\" \"$version\"") && 
				die $dir . "/opkg/patchsrcversion.sh returned non-zero result\n";;
		};

		call_system ("make -C" . $dir . "/" . $buildconfig . " -f makefile clean 2>&1 > /dev/null");
		$verbose && print " * Building ...\n";
		call_system ("make -C" . $dir . "/" . $buildconfig . " -f makefile " . $redir);

	} else {
		die "Unable to find Makefile, makefile, build.xml or Eclipse-style makefile. Abort.\n";
	};

	# create root directory to install to

	mkdir $ENV{'HOME'} . "/opkg/root";
	mkdir $ENV{'HOME'} . "/opkg/ar";

	# call install sh, while current dir is source dir. Pass in root dir
	# and also buildconfig (if we have one).

	if ( -e $dir . "/opkg/install.sh" ) {

		$verbose && print " * Installing into " . $ENV{'HOME'} . "/opkg/root\n";

		call_system ($dir . "/opkg/install.sh \"" . $ENV{'HOME'} . "/opkg/root" . "\" \"${dir}\" \"${buildconfig}\" " . $redir) && die "Aborting, \"" . $dir . "/opkg/install.sh \"" . $ENV{'HOME'} . "/opkg/root\" \"$buildconfig\" returned non-zero result.";

	} else {
		die "Unable to find $dir/opkg/install.sh\n";
	};

	# tar up the root to make data.tar.gz
	$verbose && print " * Making data.tar.gz\n";
	call_system ("fakeroot tar czpfC " . $ENV{'HOME'}. "/opkg/ar/data.tar.gz " . $ENV{'HOME'}."/opkg/root .") && die "Failed to make data.tar.gz\n";

	# patch control
	$verbose && print " * Patching control file.\n";
	call_system (
		"sed ".
			"-e 's/^Package:.*/Package: ${project}${currentBranch}/' ".
			"-e 's/^Version:.*/Version: ${version}/' ".
			"-i ${dir}/opkg/control/control" 
		) && die "Failed to patch Package and Version in opkg/control\n";


	# tar up control to make control.tar.gz
	$verbose && print " * Making control.tar.gz\n";
	call_system ("fakeroot tar czpfC " . $ENV{'HOME'}. "/opkg/ar/control.tar.gz " . $dir . "/opkg/control .") && die "Failed to make control.tar.gz\n";


	# copy over debian-binary
	$verbose && print " * Copying debian-binary\n";
	call_system ("cp " . $dir . "/opkg/debian-binary " . $ENV{'HOME'} .
		"/opkg/ar/debian-binary") && die "Failed to copy debian-binary\n";

	# building ipkg
	$verbose && print " * Building ${project}${currentBranch}-${version}.ipk\n";
	chdir ($ENV{'HOME'} . "/opkg/ar");
	call_system ("ar -r " . $ENV{'HOME'} . "/opkg/${project}${currentBranch}-${version}.ipk debian-binary control.tar.gz data.tar.gz") && die
		"failed to ar ${project}${currentBranch}-${version}.ipk\n";

	# publish if required
	if ( $publish ) {

		if (-e $dir . "/opkg/publish.sh") {
			$verbose && print " * publishing ${project}${currentBranch}-${version}.ipk\n";
			call_system ($dir . "/opkg/publish.sh \"" . $ENV{'HOME'} . "/opkg/${project}${currentBranch}-${version}.ipk\" \"${project}${currentBranch}-${version}.ipk\"") &&
				die "Abort, publish.sh returned non-zero status\n";
		} else {
			die ("Abort, unable to publish as there is no " . $dir . "/opkg/publish.sh");
		};

	}

	print "Done.\n";
}

# ========================================================================
# buildrpmsource
# ------------------------------------------------------------------------

sub buildrpmsource {

	shift @ARGV;

	my $verbose = 0;

	my $pub_cmd = $ENV{'GITPKGTOOL_PUB_CMD'};
	my $pub_dir = $ENV{'GITPKGTOOL_PUB_DIR'};
	my $pub_postexec = $ENV{'GITPKGTOOL_PUB_POSTEXEC'};
	my $pub     = 0;
	my $pubsrc  = 0;

	if ( -e ".gitpkgtool" ) {
	  require "./.gitpkgtool"
	}

	my ($opt) = GetOptions (
		'help'	=> \$helpflag,
		'verbose' => \$verbose,
		'debug' => \$debug,
		'pub_cmd=s' => \$pub_cmd,
		'pub_dir=s' => \$pub_dir,
		'pub_postexec=s' => \$pub_postexec,
		'pub' => \$pub,
		'pubsrc' => \$pubsrc
	);

	if (!$opt || $helpflag) {
		print STDERR 
			"\ngitpkgtool buildrpmsource [--options] <tag> [source]\n".
			"\nOptions:\n".
			"  --verbose - emits running commentary\n".
			"  --debug - show details of external commands\n".
			"  --pub_cmd - command to exec when publishing\n".
			"  --pub_dir - user\@host:/dir of scp dest for publishing\n".
			"  --pub_postexec - execute command after publishing\n".
			"  --pub     - publish the Binary RPMS\n".
			"  --pubsrc  - publish the Binary & Source RPMS\n";
		exit (1);
	};


	my ($buildtag, $reposource) = @ARGV;

	# prepare RPM build area
	# We now use "rpmdev-setuptree" from rpmdevtools for this. Which
	# means the rpm build dir has moved from ~/rpm to ~/rpmbuild.

	$verbose && print STDERR " * Preparing RPM build area\n";
	call_system ("rm -rf ~/rpmbuild");
	call_system ("rpmdev-setuptree");

	
	#$debug && print STDERR "   Writing " . $ENV{'HOME'}."/.rpmrc\n";
	#open (F, "> " . $ENV{'HOME'} . "/.rpmrc") ||
	#	die "Failed to open " . $ENV{'HOME'} . "/.rpmrc for writing.\n";
	#print F "buildarchtranslate: i386: i386\n";
	#print F "buildarchtranslate: i486: i386\n";
	#print F "buildarchtranslate: i586: i386\n";
	#print F "buildarchtranslate: i686: i386\n";
	#print F "buildarchtranslate: athlon: i386\n";
	#close (F);

	# make some other folders that we need.

	foreach my $d (
			$ENV{'HOME'} . "/rpmbuild/tmp",
			$ENV{'HOME'} . "/rpmbuild/git",
			$ENV{'HOME'} . "/rpmbuild/tar",
	) {
			$debug && print STDERR "   Creating folder $d\n";
			call_system ("rm -rf $d");
			mkdir $d || die "Failed to mkdir $d\n";
	};


	my $dir = ".";
	my $project = "";

	if (defined $reposource) {
		
		# user specified a repo to pull frm
		$dir = $ENV{'HOME'} . "/rpmbuild/git";
		$verbose && print STDERR " * Cloning $reposource to $dir\n";

		mkdir $dir;
		chdir $dir;

		# clone the repo
		my $ret = call_system ("git clone -q $reposource") &&
			die "\"git clone $reposource\" failed.";

		# we need the name of the project
		opendir (DH, $dir);
		while ( my $fn = readdir (DH)) {
			if ($fn !~ /^\./) {
				$project = $fn;
			};
		};
		closedir (DH);
		chdir ($dir . "/" . $project) ||
			die "Failed to chdir to $dir/$project\n";

	} else {

		# use source in current directory.
		my $nowdir = cwd;
		$verbose && print STDERR " * Using source in $nowdir\n";

		$project = basename ($nowdir);
	};

	my $currentBranch = getCurrentBranch();
	if ($currentBranch eq 'master' || $currentBranch eq '') {
		$currentBranch = '';
	} else {
		$currentBranch = '_' . $currentBranch;
	}

	# Checkout the specified build
	if ($buildtag ne '') {
		$verbose && print STDERR " * Checking out build $buildtag\n";
		call_system ("git checkout -q $buildtag");
	};

	# get the current git version from "git describe"
	open (F, "git describe|") || die "Unable to pipe from \"git describe\"";
	$buildtag = <F>;
	close (F);
	chomp $buildtag;
	if ($buildtag eq '') {
		die ("source is not tagged properly, unable to build.\n");
	};

	# work up a version number
	my $version = buildToVersion ($buildtag);
	$verbose && print STDERR " * building $buildtag as version $version\n";

	# copy the SPEC file over, setting version numbers.
	my $specfile = $ENV{'HOME'} . "/rpmbuild/SPECS/$project.spec";
	open (FO, "> $specfile");

	# parse through specfile
	open (FI, "$project.spec") || die "There is no $project.spec file in ".
		"the source.\n";
	while (my $line = <FI>) {
		
		# replace version number
		if ($line =~ /^Version:/) {
			$line = "Version: $version\n";
		};
		if ($line =~ /^Source:/) {
			$line = "Source: ${project}${currentBranch}-${version}.tar.gz\n";
		};
		if ($line =~ /^Release:/) {
			$line = "Release: 1%{?dist}%{?repo}\n";
		};


		if ($line =~ /^%changelog/) {

			# generate changelog from git log

			print FO "%changelog\n";
			my $lastauthor = "";
			open (FC, "git log |");
			while (my $line = <FC>) {
				chomp ($line);
				if ($line =~ /^commit/) { next; };
				if ($line =~ /^Merge:/) { next; };
				if ($line =~ /^Author:\s(.*)$/) {
					$lastauthor = $1;
					next;
				};
				if ($line =~ /^Date:\s+(\w+)\s+(\w+)\s+(\w+)\s+[\w:]+\s(\d+)\s/) {
					print FO "\n * $1 $2 $3 $4 $lastauthor\n";
					next;
				};
				if ($line =~ /^\s*$/) {
					next;
				};
				$line =~ s/^\s+//;
				print FO " - $line\n";
			};
			close (FC);
			next;
		};

		# pass through other spec file lines
		print FO $line;
	};
	close (FI);

	close (FO);
	$verbose && print STDERR " * RPM SPEC is in $specfile\n";

	# Copy all other files to SOURCES
	opendir (DH, ".") || die "Failed to open current directory";
	while (my $file = readdir (DH)) {
		if ($file =~ "^\\." || $file eq "debian" || $file eq "README") {
			next;
		};
		call_system ("/bin/cp " . ($debug ? "-v " : "") . $file . " " .
			$ENV{'HOME'} . "/rpmbuild/SOURCES") && 
			die "Failed to copy $file to /rpmbuild/SOURCES";
	};
	closedir (DH);

	# invoke rpmbuild
	$verbose && print STDERR " * Invoking rpmbuild ...\n";
	call_system ("rpmbuild -ba " . ($debug ? "": "--quiet ") . "$specfile") &&
		die ("rpmbuild of $project.spec failed.\n");

	# scp
	my $findcmd = "find " . $ENV{'HOME'} . "/rpmbuild -type f -name \*.rpm " .
		($pub ? " ! -name \\*src.rpm" : "");
	if ($pub || $pubsrc) {
		my $filelist;
		open (F, "$findcmd |");
		while (my $line = <F>) {
			chomp $line;
			$filelist .= $line . " ";
		};
		my $pubcmd = $pub_cmd . " $filelist ".  $pub_dir;
		$verbose && print STDERR " * Publishing files ...\n";
		call_system ($pubcmd);

		if (defined $pub_postexec) {
			$verbose && print STDERR " * Executing post-publish script ...\n";
			call_system ($pub_postexec);
		}
	};
	
	# list output 
	$verbose && print STDERR " * Output:\n\n";
	call_system ($findcmd);
	$verbose && print STDERR "\n\n";



};

# ========================================================================
# build setup
# ------------------------------------------------------------------------

sub buildsetup {

	shift @ARGV;

	my $verbose = 0;

	my $pub_cmd = $ENV{'GITPKGTOOL_PUB_CMD'};
	my $pub_dir = $ENV{'GITPKGTOOL_PUB_DIR'};
	my $pub_postexec = $ENV{'GITPKGTOOL_PUB_POSTEXEC'};
	my $pub     = 0;
	my $pubsrc  = 0;

	if ( -e ".gitpkgtool" ) {
	  require "./.gitpkgtool"
	}
	

	my ($opt) = GetOptions (
		'help'	=> \$helpflag,
		'verbose' => \$verbose,
		'debug' => \$debug,
		'pub_cmd=s' => \$pub_cmd,
		'pub_dir=s' => \$pub_dir,
		'pub_postexec=s' => \$pub_postexec,
		'pub' => \$pub,
		'pubsrc' => \$pubsrc
	);

	if (!$opt || $helpflag) {
		print STDERR 
			"\ngitpkgtool buildsetup [--options] <tag> [source]\n".
			"\nOptions:\n".
			"  --verbose - emits running commentary\n".
			"  --debug - show details of external commands\n".
			"  --pub_cmd - command to exec when publishing\n".
			"  --pub_dir - user\@host:/dir of scp dest for publishing\n".
			"  --pub_postexec - execute command after publishing\n".
			"  --pub     - publish the setup .exe\n".
			"  --pubsrc  - publish the setup .exe\n";
		exit (1);
	};


	my ($buildtag, $reposource) = @ARGV;

	if ( ! -e 'InnoSetup.iss' ) {
		die "InnoSetup.iss not found in current directory\n";
	};

	# prepare Build Output folder

	$verbose && print STDERR " * Preparing Output area\n";

	call_system ("rm -rf Output");
	mkdir "Output" || die "Failed to mkdir Output\n";

	# use source in current directory.
	my $nowdir = cwd;
	$verbose && print STDERR " * Using source in $nowdir\n";

	my $currentBranch = getCurrentBranch();
	if ($currentBranch eq '(no branch)') {
		$currentBranch = '';
	} elsif ($currentBranch eq 'master') {
		$currentBranch = '';
	} else {
		$currentBranch = '_' . $currentBranch;
	}

	# Checkout the specified build
	if ($buildtag ne '') {
		$verbose && print STDERR " * Checking out build $buildtag\n";
		call_system ("git checkout -q $buildtag");
	};

	# if it has a makefile, call "make distclean"
	if ( -e "Makefile" || -e "makefile" ) {
		call_system ("make distclean 2>&1 > /dev/null");
	};

	# if it's Eclipse, look for Release* and Debug* subdirectories.
	opendir (DH, ".");
	while (my $fn = readdir (DH)) {
		if ( ($fn =~ /^Release/ && -d $fn) ||
		     ($fn =~ /^Debug/ && -d $fn) ) {
			chdir ($fn);
			call_system ("make clean 2>&1 > /dev/null");
			chdir ("..");
		};
	};

	# get the current git version from "git describe"
	open (F, "git describe|") || die "Unable to pipe from \"git describe\"";
	$buildtag = <F>;
	close (F);
	chomp $buildtag;
	if ($buildtag eq '') {
		die ("source is not tagged properly, unable to build.\n");
	};

	# work up a version number
	my $version = buildToVersion ($buildtag);
	$verbose && print STDERR " * building $buildtag as version $version\n";

	# copy the SPEC file over, setting version numbers and editing
	# other tags on the fly.
	open (FO, "> $nowdir/InnoSetup.tmp.iss");

	print FO "#define MyAppBranch \"${currentBranch}\"\n";
	print FO "#define MyAppVersion \"${version}\"\n";

	# parse through specfile
	open (FI, "$nowdir/InnoSetup.iss") || die "There is no InnoSetup.iss file in ".
		"the source.\n";
	while (my $line = <FI>) {
		# pass through other spec file lines
		if ($line =~ /^#define MyAppVersion/) {
			next;
		};
		print FO $line;
	};
	close (FI);

	close (FO);
	$verbose && print STDERR " * Using config from $nowdir/InnoSetup.tmp.iss\n";

	# invoke rpmbuild
	$verbose && print STDERR " * Invoking InnoSetup ...\n";
	call_system ("wine \"C:/Program Files (x86)/Inno Setup 5/iscc.exe\" InnoSetup.tmp.iss") &&
		die ("Failed to build setup.exe\n");

	# scp
	my $findcmd = "find Output -type f -name \*.exe ";
	if ($pub || $pubsrc) {
		my $filelist;
		open (F, "$findcmd |");
		while (my $line = <F>) {
			chomp $line;
			$filelist .= $line . " ";
		};
		my $pubcmd = $pub_cmd . " $filelist ".  $pub_dir;
		$verbose && print STDERR " * Publishing files ...\n";
		call_system ($pubcmd);

		if (defined $pub_postexec) {
			$verbose && print STDERR " * Executing post-publish script ...\n";
			call_system ($pub_postexec);
		}
	};
	
	# list output 
	$verbose && print STDERR " * Output:\n\n";
	call_system ($findcmd);
	$verbose && print STDERR "\n\n";



};



sub buildnsis {

	shift @ARGV;

	my $verbose = 0;
	my $reposource;
	my $buildtag;

	my ($opt) = GetOptions (
		'help'	=> \$helpflag,
		'verbose' => \$verbose,
		'debug' => \$debug,
		'reposource=s' => \$reposource,
		'buildtag=s' => \$buildtag
	);

	if (!$opt || $helpflag) {
		print STDERR 
			"\ngitpkgtool buildrpm [--options] <tag> [source]\n".
			"\nOptions:\n".
			"  --verbose - emits running commentary\n".
			"  --debug - show details of external commands\n";
		exit (1);
	};


	my ($buildtag, $reposource) = @ARGV;

	# prepare work area
	
	my $dir = File::Temp::tempdir (CLEANUP => 1, DIR => ".");

	$verbose && print STDERR " * Working directory is ./${dir}\n";
	mkdir "$dir/source";
	mkdir "$dir/output";

	my $project = "";

	if (defined $reposource) {
		
		# user specified a repo to pull frm
		$verbose && print STDERR " * Cloning $reposource to $dir\n";

		mkdir $dir . "/git";
		chdir $dir ."/git";

		# clone the repo
		my $ret = call_system ("git clone -q $reposource") &&
			die "\"git clone $reposource\" failed.";

		# we need the name of the project
		opendir (DH, $dir);
		while ( my $fn = readdir (DH)) {
			if ($fn !~ /^\./) {
				$project = $fn;
			};
		};
		closedir (DH);
		chdir ($dir . "/" . $project) ||
			die "Failed to chdir to $dir/$project\n";

	} else {

		# use source in current directory.
		my $nowdir = cwd;
		$verbose && print STDERR " * Using source in $nowdir\n";

		$project = basename ($nowdir);
	};

	my $currentBranch = getCurrentBranch();
	if ($currentBranch eq 'master' || $currentBranch eq '') {
		$currentBranch = '';
	} else {
		$currentBranch = '_' . $currentBranch;
	}

	# Checkout the specified build
	if ($buildtag ne '') {
		$verbose && print STDERR " * Checking out build $buildtag\n";
		call_system ("git checkout -q $buildtag");
	};

	$verbose && print STDERR " * Cleaning project source $project\n";

	# if it has a makefile, call "make distclean"
	if ( -e "Makefile" || -e "makefile" ) {
		call_system ("make distclean 2>&1 > /dev/null");
	};

	# if it's Eclipse, look for Release* and Debug* subdirectories.
	opendir (DH, ".");
	while (my $fn = readdir (DH)) {
		if ( ($fn =~ /^Release/ && -d $fn) ||
		     ($fn =~ /^Debug/ && -d $fn) ) {
			chdir ($fn);
			call_system ("make clean 2>&1 > /dev/null");
			chdir ("..");
		};
	};

	# get the current git version from "git describe"
	open (F, "git describe|") || die "Unable to pipe from \"git describe\"";
	$buildtag = <F>;
	close (F);
	chomp $buildtag;
	if ($buildtag eq '') {
		die ("source is not tagged properly, unable to build.\n");
	};

	# work up a version number
	my $version = buildToVersion ($buildtag);
	$verbose && print STDERR " * Copying source to " . $dir . "/source/${project}${currentBranch}-${version}\n";


	# copy into a folder of $project-$version 
	mkdir $dir . "/source/${project}${currentBranch}-$version";
	call_system ("tar czf - --exclude ".
		"./$project.spec --exclude ./.git --exclude ./debian --exclude $dir . ".
		"| tar xpzfC ".
		"- " . $dir . "/source/${project}${currentBranch}-${version}") &&
		die "Failed to build temporary tarfile";

	# call "gitpkgtool-buildrpm-post-source-copy-hook" if it exists
	if (-x "gitpkgtool-buildrpm-post-source-copy-hook" ) {
		$verbose && print STDERR " * Calling gitpkgtool-buildrpm-post-source-copy-hook\n";
		my $ret = call_system ("./gitpkgtool-buildrpm-post-source-copy-hook \"${version}\" \"" . $dir . "/source/${project}${currentBranch}-${version}\"");
		if ($ret != 0) {
			die "failed calling gitpkgtool-buildrpm-post-source-copy-hook\n";
		}
	};

	$verbose && print STDERR " * building $buildtag as version $version\n";
	$verbose && print STDERR "Executing [.nsisbuild.sh \"$project${currentBranch}\" \"${version}\"]\n";

	mkdir $dir . "/output";

	chdir $dir . "/source/$project${currentBranch}-${version}";
	system ("./.nsisbuild.sh \"$project${currentBranch}\" \"${version}\" \"../../output\"");

	# we should be in {project}/{temp}/source/Datalogger, so this should bring
	# us back to {project}/{temp}.

	chdir "../..";


	# write a VERSION.txt into the output folder.
	open (FO, ">output/VERSION.txt");
	print FO "${project}${currentBranch}-${version}\n";
	close (FO);



	# copy the .nsi file over, and edit the pkgname and version.

	my $nsifile = "$project.nsi";
	open (FO, "> ${project}.nsi");

	# parse through specfile
	open (FI, "../${project}.nsi") || die "There is no $project.nsi file in ".
		"the source.\n";
	while (my $line = <FI>) {
		# replace version number
		if ($line =~ /^\!define VERSION /) {
			$line = "!define VERSION \"$version\"\n";
		};
		if ($line =~ /^\!define PKGNAME /) {
			$line = "!define PKGNAME \"$project\"\n";
		};

		# pass through other spec file lines
		print FO $line;
	};
	close (FI);
	close (FO);
	$verbose && print STDERR " * Generated .nsi file as $dir/${project}.nsi\n";

	$verbose && print STDERR " * Building installer as ${project}${currentBranch}-${version}.exe\n";

	# ubuntu pkgs has it in /usr/bin, centos src compiles to /usr/local/bin.

	#system ("/bin/sh");

	system ("makensis ${project}.nsi");


#			# generate changelog from git log
#
#			print FO "%changelog\n";
#			my $lastauthor = "";
#			open (FC, "git log |");
#			while (my $line = <FC>) {
#				chomp ($line);
#				if ($line =~ /^commit/) { next; };
#				if ($line =~ /^Merge:/) { next; };
#				if ($line =~ /^Author:\s(.*)$/) {
#					$lastauthor = $1;
#					next;
#				};
#				if ($line =~ /^Date:\s+(\w+)\s+(\w+)\s+(\w+)\s+[\w:]+\s(\d+)\s/) {
#					print FO "\n * $1 $2 $3 $4 $lastauthor\n";
#					next;
#				};
#				if ($line =~ /^\s*$/) {
#					next;
#				};
#				$line =~ s/^\s+//;
#				print FO " - $line\n";
#			};
#			close (FC);
#			next;
#		};

	#system ("/usr/local/bin/makensys

}
